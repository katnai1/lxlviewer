<script>
/*
  The full version history view
*/
import { get, set, cloneDeep, isEmpty, isEqual, isObject } from 'lodash-es';
import { mapGetters } from 'vuex';
import * as LxlDataUtil from 'lxljs/data';
import * as VocabUtil from 'lxljs/vocab';
import * as StringUtil from 'lxljs/string';
import * as DataUtil from '@/utils/data';
import LensMixin from '@/components/mixins/lens-mixin';
import EntityForm from './entity-form.vue';
import TabMenu from '@/components/shared/tab-menu';
import VersionHistoryChangesets from './version-history-changesets.vue';

export default {
  mixins: [LensMixin],
  props: {
  },
  data() {
    return {
      historyData: null,
      modified: null,
      selectedVersion: 0,
      displayData: null,
      previousVersionData: null,
      currentVersionData: null,
      focusedTab: 'mainEntity',
      inspectingPath: '',
      showSideCol: false,
      isFocusTrapActive: false,
    };
  },
  computed: {
    ...mapGetters([
      'inspector',
      'resources',
      'user',
      'settings',
      'status',
    ]),
    focusData() {
      if (this.displayData) {
        return this.displayData.mainEntity;
      }
      return this.inspector.data.mainEntity;
    },
    selectedChangeSet() {
      return this.changeSetsReversed[this.selectedVersion];
    },
    changeSets() {
      if (this.historyData != null && this.historyData.hasOwnProperty('changeSets')) {
        // Reject changesets where the only thing that changed was 'modified'
        const hasOnlyModified = changeSet => changeSet.hasOwnProperty('addedPaths')
        && changeSet.hasOwnProperty('removedPaths')
        && changeSet.addedPaths.length === 1
        && changeSet.addedPaths[0].includes('modified')
        && changeSet.removedPaths.length === 1
        && changeSet.removedPaths[0].includes('modified');

        return this.historyData.changeSets.filter(changeSet => !hasOnlyModified(changeSet));
      }
      return null;
    },
    changeSetsReversed() {
      if (this.changeSets != null) {
        return [...this.changeSets].reverse();
      }
      return null;
    },
    currentVersionDiff() {
      return {
        added: this.addedPathsAndObjects,
        removed: this.removedPathsAndObjects,
        modified: [],
      };
    },
    addedPathsAndObjects() {
      if (this.selectedChangeSet.hasOwnProperty('addedPaths') === false) return [];
      const added = this.selectedChangeSet.addedPaths;
      const convertedAdded = [];
      added.forEach((addedPath) => {
        const thePath = StringUtil.arrayPathToString(addedPath);
        const objectAtPath = get(this.currentVersionData, thePath);
        if (thePath.endsWith('.@id') && !thePath.endsWith('mainEntity.@id')) {
          const elementPath = thePath.slice(0, thePath.lastIndexOf('.'));
          if (this.isListItem(elementPath)) {
            convertedAdded.push({ path: elementPath, val: { '@id': objectAtPath } });
          } else {
            // Put non-repeatable properties, such as descriptionLastModifier, into a list to be able to show
            // added + removed side by side.
            convertedAdded.push({ path: elementPath.concat('[1]'), val: { '@id': objectAtPath } });
          }
        } else {
          convertedAdded.push({ path: thePath, val: objectAtPath });
        }
      });
      return convertedAdded;
    },
    removedPathsAndObjects() {
      if (this.selectedChangeSet.hasOwnProperty('removedPaths') === false) return [];
      const removed = this.selectedChangeSet.removedPaths;
      const convertedRemoved = [];
      removed.forEach((removedPath) => {
        const thePath = StringUtil.arrayPathToString(removedPath);
        const objectAtPath = get(this.previousVersionData, thePath);

        if (thePath.includes('instanceOf.@id')) {
          return;
        }

        if (thePath.endsWith('.@id') && !thePath.endsWith('mainEntity.@id')) {
          const elementPath = thePath.slice(0, thePath.lastIndexOf('.'));
          if (this.isListItem(elementPath)) {
            convertedRemoved.push({ path: elementPath, val: { '@id': objectAtPath } });
          } else {
            // Put non-repeatable properties, such as descriptionLastModifier, into a list to be able to show
            // added + removed side by side.
            convertedRemoved.push({ path: elementPath.concat('[0]'), val: { '@id': objectAtPath } });
          }
        } else {
          convertedRemoved.push({ path: thePath, val: objectAtPath });
        }
      });
      return convertedRemoved;
    },
    recordType() {
      if (this.displayData.hasOwnProperty('mainEntity')) {
        return VocabUtil.getRecordType(
          this.displayData.mainEntity['@type'],
          this.resources.vocab,
          this.resources.context,
        );
      }
      return null;
    },
    editorTabs() {
      return [{ id: 'mainEntity', text: this.$options.filters.labelByLang(this.recordType) },
        { id: 'record', text: 'Admin metadata' }];
    },
  },
  watch: {
    selectedVersion(val, oldval) {
      if (val !== oldval) {
        this.setDisplayDataFor(val);
      }
    },
    'inspector.event'(val) {
      if (val.name === 'field-label-clicked') {
        const lastChanged = this.changeSetsReversed.find((changeSet) => {
          if (changeSet.hasOwnProperty('addedPaths') || changeSet.hasOwnProperty('removedPaths')) {
            const all = changeSet.addedPaths.concat(changeSet.removedPaths);
            return all.find(path => StringUtil.arrayPathToString(path).includes(val.value));
          }
          return false;
        });
        let index;
        if (lastChanged === undefined) {
          index = this.changeSetsReversed.length - 1; // Latest change was in the first version
        } else {
          index = this.changeSetsReversed.indexOf(lastChanged);
        }
        this.changeSelectedVersion(index);
      }
    },
  },
  methods: {
    isListItem(path) {
      return path.slice(-1) === ']';
    },
    goToRecord() {
      const fnurgel = this.$route.params.fnurgel;
      this.$router.push({ path: `/${fnurgel}` });
    },
    changeSelectedVersion(val) {
      this.selectedVersion = val;
      this.closeSideCol();
    },
    setEditorFocus(value) {
      this.focusedTab = value;
      this.$store.dispatch('pushInspectorEvent', { name: 'form-control', value: 'focus-changed' });
    },
    setDefaultFocusedTab() {
      if (!this.currentVersionDiff.added.some(el => el.path.includes('mainEntity'))
        && !this.currentVersionDiff.removed.some(el => el.path.includes('mainEntity'))) {
        this.focusedTab = 'record';
      } else {
        this.focusedTab = 'mainEntity';
      }
    },
    setDisplayData() {
      const fnurgel = this.$route.params.fnurgel;
      // _changesets
      const fetchUrl = `${this.settings.apiPath}/${fnurgel}/_changesets`;
      fetch(fetchUrl).then(response => response.json()).then((result) => {
        this.historyData = result;
        const agents = (this.changeSets || []).map(c => c.agent).filter(a => a);
        DataUtil.fetchMissingLinkedToQuoted(agents, this.$store);

        this.setDisplayDataFor(0);
        this.isFocusTrapActive = true;
      });
    },
    async setDisplayDataFor(number) {
      if (this.changeSetsReversed == null) return;

      const options = {
        headers: {
          Accept: 'application/ld+json',
        },
      };

      const fetchUrl = this.changeSetsReversed[number].version['@id'];
      this.currentVersionData = await fetch(fetchUrl, options)
        .then(response => response.json())
        .then(result => DataUtil.moveWorkToInstance(LxlDataUtil.splitJson(result)));

      const previousChangeSet = this.changeSetsReversed[number + 1];
      if (previousChangeSet === undefined) {
        this.displayData = this.currentVersionData;
        return;
      }

      this.previousVersionData = await fetch(previousChangeSet.version['@id'], options)
        .then(response => response.json())
        .then(result => DataUtil.moveWorkToInstance(LxlDataUtil.splitJson(result)));

      const diff = this.currentVersionDiff;
      const compositeVersionData = cloneDeep(this.previousVersionData);
      const updatedPaths = [];

      [...diff.added, ...diff.removed].forEach((item) => {
        const parentPath = item.path.slice(0, item.path.lastIndexOf('['));
        if (updatedPaths.indexOf(parentPath) === -1) {
          updatedPaths.push(parentPath);
        }
      });

      const checkConflict = (item, compare) => {
        const updated = compare.find(compareItem => isEqual(compareItem.path, item.path));
        if (updated != null && item.val !== updated.val) {
          if (typeof item.val === 'string' && typeof updated.val === 'string') {
            const from = StringUtil.getLabelByLang(updated.val, this.user.settings.language, this.resources);
            const to = StringUtil.getLabelByLang(item.val, this.user.settings.language, this.resources);
            const moddedValue = from.concat(' â†’ ').concat(to);
            diff.modified.push({ path: item.path, val: moddedValue });
            set(compositeVersionData, item.path, moddedValue);
          }
        } else {
          set(compositeVersionData, item.path, item.val);
        }
      };

      if (!isEmpty(updatedPaths)) {
        updatedPaths.forEach((parentPath) => {
          const objAtPath = get(compositeVersionData, parentPath);

          const pathRemoved = diff.removed.map((item) => {
            if (parentPath === item.path.slice(0, item.path.lastIndexOf('['))) {
              return item;
            }

            return false;
          }).filter(r => r);

          const pathAdded = diff.added.map((item) => {
            if (parentPath === item.path.slice(0, item.path.lastIndexOf('['))) {
              return item;
            }

            return false;
          }).filter(r => r);

          if (objAtPath != null && Array.isArray(objAtPath)) {
            const conflictingPathNames = pathRemoved.find(removed => pathAdded.find(added => isEqual(added.path, removed.path))) != null;
            const addedEntity = get(this.currentVersionData, parentPath);

            if (!conflictingPathNames) {
              // Under the same parent property but not the same key
              if (Array.isArray(addedEntity)) {
                addedEntity.forEach((entity) => {
                  const inPath = objAtPath.find(pathObject => pathObject['@id'] === entity['@id']);
                  if (inPath == null) {
                    objAtPath.push(entity);
                  }
                });
              } else {
                const inPath = objAtPath.find(pathObject => pathObject['@id'] === addedEntity['@id']);
                if (inPath == null) {
                  objAtPath.push(addedEntity);
                }
              }

              return parentPath;
            }
          }

          if (pathRemoved.length > 0 && pathAdded.length > 0) {
            pathRemoved.forEach((item) => {
              checkConflict(item, pathAdded);
            });
          }

          pathAdded.forEach((item) => {
            if (this.isListItem(item.path) && isObject(item.val)) {
              if (Array.isArray(objAtPath)) {
                objAtPath.push(item.val);
                set(compositeVersionData, parentPath, objAtPath);
              } else {
                const parent = [];
                parent.push(item.val);
                parent.push(objAtPath);
                set(compositeVersionData, parentPath, parent);
              }
            } else {
              checkConflict(item, pathRemoved);
            }
          });

          return parentPath;
        });
      }

      // Fix diff indexes
      if (diff != null) {
        diff.added = diff.added.map(added => this.updateDiffIndex(added, compositeVersionData.mainEntity));
        diff.removed = diff.removed.map(removed => this.updateDiffIndex(removed, compositeVersionData.mainEntity));
        diff.modified = diff.modified.map(modified => this.updateDiffIndex(modified, compositeVersionData.mainEntity));
      }

      this.fetchMissingLinks(compositeVersionData);
      await this.$store.dispatch('setCompositeHistoryData', compositeVersionData);
      this.displayData = compositeVersionData;
      this.setDefaultFocusedTab();
    },
    fetchMissingLinks(data) {
      const toFetch = cloneDeep(data);
      delete toFetch.mainEntity.sameAs;
      delete toFetch.record.sameAs;
      DataUtil.fetchMissingLinkedToQuoted(toFetch, this.$store);
    },
    openSideCol() {
      this.showSideCol = true;
    },
    closeSideCol() {
      this.showSideCol = false;
    },
    findValue(obj, value) {
      const result = {};

      function findValueHelper(current, val, path) {
        for (const key in current) {
          if (current.hasOwnProperty(key)) {
            const newPath = path ? `${path}.${key}` : key;
            if (current[key] === val) {
              result.value = current[key];
              result.path = newPath;
            }

            if (typeof current[key] === 'object') {
              findValueHelper(current[key], val, newPath);
            }
          }
        }
      }

      findValueHelper(obj, value);
      return result;
    },
    updateDiffIndex(diff, entity) {
      const result = this.findValue(entity, diff.val);

      if (result.path != null) {
        const diffIndex = diff.path.lastIndexOf('[') + 1;
        if (diffIndex > 0) {
          const indexes = result.path.replace(/[^0-9.]/g, '').split('.').filter(index => index !== '');
          const newPath = diff.path.substring(0, diffIndex) + indexes[indexes.length - 1] + diff.path.substring(diffIndex + 1);
          diff.path = newPath;
        }
      }

      return diff;
    },
  },
  components: {
    EntityForm,
    TabMenu,
    VersionHistoryChangesets,
  },
  mounted() {
    this.$nextTick(() => {
      this.setDisplayData();
    });
  },
};
</script>

<template>
  <focus-trap v-model=isFocusTrapActive>
    <div class="VersionHistory" tabindex="-1">
      <div class="Container-row">
        <div class="VersionHistory-mainCol">
          <div class="VersionHistory-header">
            <span class="VersionHistory-backLink">
              <a @click="goToRecord" @keyup.enter="goToRecord" tabindex="0">
                <i class="fa fa-arrow-left VersionHistory-back-icon"></i>{{ $filters.translatePhrase('Back') }}
              </a>
            </span>

            <span class="VersionHistory-headerTitle" v-if="displayData != null">
              {{ getItemLabel }}
            </span>

            <i class="fa fa-th-list icon icon--md sideColButton"
               role="button"
               @click="openSideCol()"></i>
          </div>

          <div class="VersionHistory-content" tabindex="-1">
            <template v-if="displayData != null">
              <tab-menu @go="setEditorFocus" :tabs="editorTabs" :active="focusedTab"/>

              <entity-form
                v-for="tab in editorTabs"
                :editing-object="tab.id"
                :key="tab.id"
                :diff="currentVersionDiff"
                :is-active="focusedTab === tab.id"
                :form-data="displayData[tab.id]"
                :locked="true">
              </entity-form>
            </template>
          </div>
        </div>

        <div class="VersionHistory-sideCol" :class="{'hidden-view': !showSideCol}">
          <div class="VersionHistory-header">
            {{ $filters.translatePhrase('Version history') }}
            <i class="fa fa-close icon icon--md sideColButton" role="button" @click="closeSideCol()"></i>
          </div>

          <VersionHistoryChangesets
            :change-sets="changeSets"
            :selected-version="selectedVersion"
            @version-selected="changeSelectedVersion"
          />
        </div>
      </div>
    </div>
  </focus-trap>
</template>

<style lang="less">
.VersionHistory {
  background-color: @bg-site;
  &-mainCol {
    height: 100vh;
    display: flex;
    overflow: hidden;
    flex-direction: column;
    flex: 3 0 0;
  }
  &-sideCol {
    box-shadow: @fullscreen-panel-shadow;
    z-index: 2;
    height: 100vh;
    flex: 1 0 0;

    @media screen and (max-width: @screen-xs-max) {
      .full-view();
    }

    .full-view() {
      top: 0px;
      left: 0px;
      width: 100%;
      opacity: 1;
      height: 100vh;
      position: fixed;
      &.hidden-view {
        display: none;
      }
    }
  }
  &-backLink {
    font-weight: normal;
    a {
      color: inherit;
    }
  }
  &-back-icon {
    margin-right: 0.3em;
  }
  &-header {
    z-index: 1;
    font-weight: 600;
    background-color: @white;
    border: solid #ccc;
    border-width: 0px 0px 1px 0px;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    padding: 1em;
  }
  &-headerTitle {
    font-weight: 600;
    margin-left: 0.5em;
    margin-right: 0.5em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  &-content {
    z-index: 0;
    padding: 2rem 3rem;
    overflow-y: scroll;
    flex-grow: 1;
  }
  &-changeSets {
    background-color: @white;
  }
  .Container-row {
    display: flex;
    flex-direction: row;
    justify-content: flex-start;
    padding: 0;
  }
  .sideColButton {
    @media screen and (min-width: @screen-xs-max) {
      display: none;
    }
  }
}

.ChangeSet {
  border-style: solid;
  border-width: 0px 0px 1px 0px;
  border-color: #ccc;
  &-dateContainer {
    flex-basis: 100%;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }
  &-changeSetContainer {
    display: flex;
    flex-wrap:wrap;
    border-style: solid;
    border-width: 0px 0px 0px 4px;
    border-color: transparent;
    padding: 0.75rem 0.75rem 0.75rem 1.5rem;
    &.selected {
      border-left-color: @brand-primary;
    }
  }
  &-currentVersion {
    flex-basis: 100%;
    font-size: 0.75em;
    text-transform: uppercase;
    &.selected {
      color: @brand-primary;
    }
  }
  &-date {
    flex: 1 0 auto;
    font-weight: 600;
    &.selected {
      color: @brand-primary;
    }
  }
  &-agent {
    flex-basis:100%;
    font-size: 0.9em;
  }
  &-tool {
    border: 1px solid @grey;
    border-radius: 2em;
    width: max-content;
    height: max-content;
    margin-right: 1em;
    margin-left: 1em;
    font-size: 0.75em;
    padding: 0 0.3em 0.1em 0.3em;
    flex: 0 0 auto;
  }
}
</style>
